title: "Gitalong: A better Github feed"
tags: express,webpack,react,github
date: 2017-10-14T22:36:36Z
header: "https://d1u0z01nzsqzn7.cloudfront.net/images/octocat.svg"
----

Two years ago I started kicking around a little project called Gitalong. A user could log in and see a feed of Github repos from all the people they were connected with (following/followed).  This could be sorted by last pushed-to, or the number of stars it had.

It could also be filtered by language, and it turned out this was a pretty neat way to get a view of what was happening in your Github social circle.  It let you see what your peers were actually working on and pushing to, at least publically.  Cool!

The Rails app that drove this was not that cool however.  By that I mean it was an elaborate cluster****.  The data flow went something like this:

- User logs in, authenticating with their Github profile.
- Redirect to '/', so the server needs to build the activity feed:
  - Get the list of "following" users from Github
  - Get the list of "followers" users from Github
  - For each user in this combined list, get the first page of their Repos
  - Serialize the list of users and the list of repos and put in a JSON response

Even for a user like myself who only modestly consumes Github's social features (I follow about ~20 people, and am followed by mostly those folks, so grand total is about 25), this meant a sizeable number of requests.

Waiting for dozens of requests to process singlefile (in ruby) wasn't really an option, so I used the following strategies:
- Sidekiq jobs to wrap the API and DB calls as a way to get some concurrency/async functionality to process the requests and db updates.
- For fun, I used Rails 5's new ActionCable feature to 'livestream' the data to the client as the data came back from Github.  It was rad watching React components get data from a websocket connection, and fairly easy to set up.  Excited to try this out again for a DIFFERENT application however.

In this way, eventually, a feed was constructed and the user could then filter it.  I never polished up and finished the project.  When I walked away from it there were plenty of bugs and UI issues that needed addressing, but it just felt like it was the wrong tech stack for it.  For an application with a specific, single purpose, it just felt wrong to have an entire Rails app spun up, complete with websocket server, psql db, and redis job queue.

But I didn't forget how cool it was to browse Github data like that; to see a stream of what folks I knew were up to in their coding endeavors (on Github).  So recently I decided to reboot the project in Express as an excuse to dive a bit deeper into Nodejs (even doing some Nodejs units on Pluralsight.com).

So far its been extremely rewarding and exciting to see the kinds of things a node backend really kicks ass at.  It also feels great to step out of Rails' convention-over-configuration and have to think critically about organizating an application.  I'm sure a number of blogposts about my learnings will follow before the project is done.
