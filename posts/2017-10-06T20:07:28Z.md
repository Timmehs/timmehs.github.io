title: "Webpack Loaders"
tags: webpack,blog,markdown,react
header: "https://camo.githubusercontent.com/d18f4a7a64244f703efcb322bf298dcb4ca38856/68747470733a2f2f7765627061636b2e6a732e6f72672f6173736574732f69636f6e2d7371756172652d6269672e737667"
date: 2017-10-06T20:07:28Z
----Content Below This Line----

Alright, this'll be my first post really consuming what I've built as a blogging platform. I just generated this markdown file with the title and relevant tags, and I'm off typing.

![alt text](https://d1u0z01nzsqzn7.cloudfront.net/images/10-06-2017-header.png "Using the `yarn post` post generator")

Between now and the last post I did a whole lot of battling with how I was going to build up the site, WITH the blogposts in their unusual format, and including them in the webpack bundle.  Here's where I landed.

### Early days
Originally I had scripts to parse all files under my `/posts` directory and build `/assets/blog-manifest.json` which consisted of something like:

```javascript
module.exports = [..JSONified blog post data...]
```

I had to call this script explicitly with `yarn build` which string this script together with webpack, something like `./bin/build-blog; webpack`.
My Blog component could then import this data, which was in a sensible enough form to map into a list of Post components to render the blog.

### Leveraging webpack
The first step I took in the right direction was to extract that script to be a webpack plugin called `BlogBuilderPlugin`, which automatically built the `blog-manifest.json` file when the compilation was finished.  This ensured at least that whenever webpack rebuilt the bundle, there would be a fresh `blog-manifest.json` for the Blog to consume.  However, I wanted the blog to be rebuilt and reloaded as I was typing up posts.

> The plugin wasn't quite what I needed, however.

What I needed was to apply my special parsing of my post files, splitting apart `title`, `date`, `tags`, `markdown` into consumable modules.  But I needed to dynamically import ALL post files in order to render, sort, filter, etc.  I can't be expected to add an import statement for every blog post.  I'm going to be writing waaaay too many to be bothered with that (smirk).

All I needed to do in the end was add a custom `post-loader` with a rule to apply it to all .md files.  I should probably change it to .post since its not technically an md file.

Here's the loader:
```
var yaml = require('js-yaml')

// Post Loader
// Convert post.md file to object { date, markdown, title, tags }
function parsePost(rawString) {
  const splitContent = rawString.split("----\n")
  const data = yaml.safeLoad(splitContent[0])
  const tags = Object.assign(...data.tags.split(',').map(k => ({ [k]: true })))

  return {
    ...data,
    tags,
    markdown: splitContent.slice(1).join('')
  }
}

module.exports = function(source) {
  return "module.exports = " + JSON.stringify(parsePost(source));
};
```

And included in `webpack.config.js`:
```javascript
  ...
    module: {
      rules: [
        {
          test: /\.md$/,
          use: [
            "post-loader"
          ]
        },
    ...
```

This loader will run for any .md file imported by code in my load path (through index.js).  The problem remains, how to load up ALL of these files at once.  Turns out there are dozens of "glob"ing packages on NPM to enable statements like this:

```

import * as blogPosts from '../../posts/*.md'

```

I happened to use a babel plugin called [babel-plugin-import-glob](https://github.com/novemberborn/babel-plugin-import-glob), but there are many others.

Thats probably not a coherent narrative, but the TL;DR is:

I have a reasonably clean platform, all handled through ES6 modules and webpack, to dynamically generate and render blog posts.

Next up:

* Blog index and filtering using dates and tags.
